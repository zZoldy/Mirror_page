package com.app.mirrorpage.ui.table;

import com.app.mirrorpage.app.framework.Funcoes;
import com.app.mirrorpage.app.framework.Log;
import com.app.mirrorpage.app.listener.Cliente_listener;
import com.app.mirrorpage.app.model.Tabela;
import com.app.mirrorpage.app.table.SyncAmbiente;
import com.app.mirrorpage.app.tema.TemaSyncClient;
import com.app.mirrorpage.client.dto.CellChangeEvent;
import com.app.mirrorpage.client.dto.RowDeletedEvent;
import com.app.mirrorpage.client.dto.RowInsertedEvent;
import com.app.mirrorpage.client.dto.RowMoveEvent;
import com.app.mirrorpage.client.net.ApiClient;
import com.app.mirrorpage.client.net.SheetSocketClient;
import com.app.mirrorpage.ui.Principal;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Font;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.net.URI;
import java.util.concurrent.atomic.AtomicBoolean;
import javax.swing.AbstractAction;
import javax.swing.ActionMap;
import javax.swing.BorderFactory;
import javax.swing.InputMap;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JSplitPane;
import javax.swing.JTable;
import javax.swing.KeyStroke;
import javax.swing.Popup;
import javax.swing.PopupFactory;
import javax.swing.SwingUtilities;
import javax.swing.SwingWorker;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellEditor;

public class jInternal_tabela extends javax.swing.JInternalFrame {

    private int lockedRow = -1;
    private int lockedCol = -1;

    private int editingViewRow = -1;
    private int editingViewCol = -1;
    private int editingModelRow = -1;
    private int editingModelCol = -1;

    private Object oldCellValue = null;
    private int oldCellRow = -1;
    private int oldCellCol = -1;

    Cliente_listener listener;
    ApiClient api;
    private SheetSocketClient wsClient;
    public SyncAmbiente sync;

    public String usuarioLogado;

    public String csv_server;

    TemaSyncClient temaSync;

    private JSplitPane splitPane;
    private Lauda laudaPanel;
    private boolean laudaVisivel = false;
    private String currentLaudaPath = null;
    private int currentLaudaRow = -1;
    private boolean isLaudaLockedByMe = false; // Controle de permiss√£o

    AtomicBoolean acao_line = new AtomicBoolean(true);

    Popup popupAtual = null;

    public jInternal_tabela(DefaultTableModel model, ApiClient api, Cliente_listener listener, String csv_server, String usuarioLogado, TemaSyncClient temaSync) {
        this.api = api;
        this.csv_server = csv_server;
        this.listener = listener;
        this.usuarioLogado = usuarioLogado;
        this.temaSync = temaSync;

        initComponents();

        this.sync = new SyncAmbiente(this, api, csv_server);

        initLaudaSystem();

        tabela_news.setModel(model);
        tabela_news.setName("news");
        System.out.println("\nCsv - " + csv_server + "\n");

        Tabela.ajustarLarguraColuna(tabela_news);

        conectarWebSocket();

        setBorder(null);
        barra_titulo();
        edicao_celula();

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        pn_tabela = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        tabela_news = new javax.swing.JTable();

        setBorder(null);
        addInternalFrameListener(new javax.swing.event.InternalFrameListener() {
            public void internalFrameActivated(javax.swing.event.InternalFrameEvent evt) {
            }
            public void internalFrameClosed(javax.swing.event.InternalFrameEvent evt) {
            }
            public void internalFrameClosing(javax.swing.event.InternalFrameEvent evt) {
                formInternalFrameClosing(evt);
            }
            public void internalFrameDeactivated(javax.swing.event.InternalFrameEvent evt) {
            }
            public void internalFrameDeiconified(javax.swing.event.InternalFrameEvent evt) {
            }
            public void internalFrameIconified(javax.swing.event.InternalFrameEvent evt) {
            }
            public void internalFrameOpened(javax.swing.event.InternalFrameEvent evt) {
                formInternalFrameOpened(evt);
            }
        });
        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentResized(java.awt.event.ComponentEvent evt) {
                formComponentResized(evt);
            }
        });

        jScrollPane1.setBorder(null);
        jScrollPane1.setName("pn_tabela"); // NOI18N

        tabela_news.setFont(new java.awt.Font("Globotipo Corporativa Textos", 1, 14)); // NOI18N
        tabela_news.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {},
                {},
                {},
                {}
            },
            new String [] {

            }
        ));
        tabela_news.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_ALL_COLUMNS);
        tabela_news.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                tabela_newsMouseDragged(evt);
            }
        });
        tabela_news.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                tabela_newsFocusLost(evt);
            }
        });
        tabela_news.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                tabela_newsMouseClicked(evt);
            }
            public void mousePressed(java.awt.event.MouseEvent evt) {
                tabela_newsMousePressed(evt);
            }
        });
        tabela_news.addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentResized(java.awt.event.ComponentEvent evt) {
                tabela_newsComponentResized(evt);
            }
        });
        tabela_news.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                tabela_newsKeyPressed(evt);
            }
            public void keyReleased(java.awt.event.KeyEvent evt) {
                tabela_newsKeyReleased(evt);
            }
        });
        jScrollPane1.setViewportView(tabela_news);

        javax.swing.GroupLayout pn_tabelaLayout = new javax.swing.GroupLayout(pn_tabela);
        pn_tabela.setLayout(pn_tabelaLayout);
        pn_tabelaLayout.setHorizontalGroup(
            pn_tabelaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 406, Short.MAX_VALUE)
        );
        pn_tabelaLayout.setVerticalGroup(
            pn_tabelaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 337, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(pn_tabela, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(pn_tabela, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void formComponentResized(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentResized
        // TODO add your handling code here:
        tabela_news.setSize(getSize());
    }//GEN-LAST:event_formComponentResized

    private void tabela_newsKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_tabela_newsKeyReleased
        if (evt.getKeyCode() == KeyEvent.VK_ENTER) {
            event_enter();
        }


    }//GEN-LAST:event_tabela_newsKeyReleased

    void event_enter() {
        // se ainda est√° em edi√ß√£o, ignora esse ENTER
        // (ele foi usado pra dar stopCellEditing no edicao_celula)
        if (tabela_news.isEditing()) {
            return;
        }

        int row = tabela_news.getSelectedRow();
        int col = tabela_news.getSelectedColumn();
        if (row < 0 || col < 0) {
            return;
        }

        int last_row = tabela_news.getRowCount() - 1;

        // VIEW -> MODEL para sincronizar com o servidor
        int modelRow = tabela_news.convertRowIndexToModel(row);
        int modelCol = tabela_news.convertColumnIndexToModel(col);

        Object valueObj = tabela_news.getModel().getValueAt(modelRow, modelCol);
        String value = (valueObj == null) ? "" : valueObj.toString();
        if (value.contains(";")) {
            value = value.replace(";", ",");
        }

        if (col == 0) {
            if (value.equals("") || value == null) {
                restaurarValorAnteriorSeMesmaCelula(modelRow, modelCol);
                return;
            }
            if (isInt(value)) {
                int new_line = Integer.parseInt(value);
                move_line(row, col, new_line);
            } else {
                restaurarValorAnteriorSeMesmaCelula(modelRow, modelCol);
            }
            return;

        }

        // TEMPO (col 8 ou 9)
        if (col == 8 || col == 9) {
            System.out.println("Coluna " + col + " Identificada");
            sync.onCellEdit(modelRow, modelCol, value);
            in_tMat(row, col, true);        // usa VIEW pra calcular tMat
            return;
        }

        // ENTRADA DO JORNAL
        if (row == 0 && col == 13) {
            System.out.println("Entrada de Jornal Identificada");
            sync.onCellEdit(modelRow, modelCol, value);
            add_tempo_entrada(modelRow, modelCol);            // dentro dele j√° chama sync
            return;
        }

        // ENCERRAMENTO DO JORNAL (aqui voc√™ usou last_row, mas talvez seja pen√∫ltima)
        if (row == last_row && col == 13) {
            System.out.println("Encerramento de Jornal Identificada");
            sync.onCellEdit(modelRow, modelCol, value);
            add_tempo_encerramento(row, col);       // dentro dele j√° chama sync
            return;
        }

        // demais c√©lulas: s√≥ sincroniza
        sync.onCellEdit(modelRow, modelCol, value);
    }

    public static boolean isInt(String s) {
        if (s == null) {
            return false;
        }
        s = s.trim();
        try {
            Integer.parseInt(s);
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    private void tabela_newsKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_tabela_newsKeyPressed
        if (evt.getKeyCode() == KeyEvent.VK_INSERT) {
            Funcoes.acao_com_trava(() -> {
                tabela_news.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

                new SwingWorker<Void, Void>() {
                    @Override
                    protected Void doInBackground() throws Exception {
                        Thread.sleep(300);
                        return null;
                    }

                    @Override
                    protected void done() {
                        try {
                            event_insert();
                            Log.registrarErro_noEx("[INSERT] - Linha inserida");
                        } finally {
                            acao_line.set(true); // üîì libera de novo
                            tabela_news.setCursor(Cursor.getDefaultCursor());
                            Log.registrarErro_noEx("[INSERT] - Linha n√£o inserida");
                        }
                    }
                }.execute();
            }, acao_line);
        }

        if (evt.getKeyCode() == KeyEvent.VK_DELETE) {
            Funcoes.acao_com_trava(() -> {
                tabela_news.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

                new SwingWorker<Void, Void>() {
                    @Override
                    protected Void doInBackground() throws Exception {
                        Thread.sleep(300);
                        return null;
                    }

                    @Override
                    protected void done() {
                        try {
                            event_delete();
                            Log.registrarErro_noEx("[DELETE] - Linha exclu√≠da");
                        } finally {
                            acao_line.set(true); // üîì libera de novo
                            tabela_news.setCursor(Cursor.getDefaultCursor());
                            Log.registrarErro_noEx("[DELETE] - Linha n√£o exclu√≠da");
                        }
                    }
                }.execute();
            }, acao_line);
        }

        if (evt.getKeyCode() == KeyEvent.VK_ENTER) {
            // 2) N√ÉO est√° editando ‚Üí tenta TRAVAR e entrar em edi√ß√£o
            int viewRowEditing = tabela_news.getSelectedRow();
            int viewColEditing = tabela_news.getSelectedColumn();

            // üîπ AQUI ainda est√° o valor ANTIGO no model
            int modelRow = tabela_news.convertRowIndexToModel(viewRowEditing);
            int modelCol = tabela_news.convertColumnIndexToModel(viewColEditing);

            oldCellValue = tabela_news.getModel().getValueAt(modelRow, modelCol);
            oldCellRow = viewRowEditing;  // guardando em coordenada de VIEW
            oldCellCol = viewColEditing;
        }

        if (evt.isAltDown() && evt.getKeyCode() == KeyEvent.VK_RIGHT) {
            int row = tabela_news.getSelectedRow();
            if (row != -1) {
                evt.consume(); // Impede que o evento fa√ßa outra coisa

                // Pega algum dado da linha para mostrar no t√≠tulo (ex: coluna 1 ou 2)
                // Ajuste o √≠ndice '1' para a coluna que tem o nome da mat√©ria/slug
                String assunto = tabela_news.getValueAt(row, 5).toString();
                String titulo = assunto;
                if(assunto.isBlank()){
                    titulo = "Sem retranca";
                }

                // Chama o Principal
                alternarLauda(titulo);
            }
        }

        if (evt.isAltDown() && evt.getKeyCode() == KeyEvent.VK_LEFT) {
            evt.consume();
            // Chama o Principal para fechar
            esconderLauda();
        }

        if (evt.isControlDown() && evt.getKeyCode() == KeyEvent.VK_F9) {
            evt.consume();
            enviarLinhaParaFinal();
        }

        if (evt.getKeyCode() == KeyEvent.VK_UP) {
            int viewRowEditing = tabela_news.getSelectedRow();
            int viewColEditing = tabela_news.getSelectedColumn();

            // üîπ AQUI ainda est√° o valor ANTIGO no model
            int modelRow = tabela_news.convertRowIndexToModel(viewRowEditing);
            int modelCol = tabela_news.convertColumnIndexToModel(viewColEditing);

            oldCellValue = tabela_news.getModel().getValueAt(modelRow, modelCol);
            oldCellRow = viewRowEditing;  // guardando em coordenada de VIEW
            oldCellCol = viewColEditing;
        }

        if (evt.getKeyCode() == KeyEvent.VK_DOWN) {
            int viewRowEditing = tabela_news.getSelectedRow();
            int viewColEditing = tabela_news.getSelectedColumn();

            // üîπ AQUI ainda est√° o valor ANTIGO no model
            int modelRow = tabela_news.convertRowIndexToModel(viewRowEditing);
            int modelCol = tabela_news.convertColumnIndexToModel(viewColEditing);

            oldCellValue = tabela_news.getModel().getValueAt(modelRow, modelCol);
            oldCellRow = viewRowEditing;  // guardando em coordenada de VIEW
            oldCellCol = viewColEditing;
        }

        if (evt.getKeyCode() == KeyEvent.VK_LEFT) {
            int viewRowEditing = tabela_news.getSelectedRow();
            int viewColEditing = tabela_news.getSelectedColumn();

            // üîπ AQUI ainda est√° o valor ANTIGO no model
            int modelRow = tabela_news.convertRowIndexToModel(viewRowEditing);
            int modelCol = tabela_news.convertColumnIndexToModel(viewColEditing);

            oldCellValue = tabela_news.getModel().getValueAt(modelRow, modelCol);
            oldCellRow = viewRowEditing;  // guardando em coordenada de VIEW
            oldCellCol = viewColEditing;
        }

        if (evt.getKeyCode() == KeyEvent.VK_RIGHT) {
            int viewRowEditing = tabela_news.getSelectedRow();
            int viewColEditing = tabela_news.getSelectedColumn();

            // üîπ AQUI ainda est√° o valor ANTIGO no model
            int modelRow = tabela_news.convertRowIndexToModel(viewRowEditing);
            int modelCol = tabela_news.convertColumnIndexToModel(viewColEditing);

            oldCellValue = tabela_news.getModel().getValueAt(modelRow, modelCol);
            oldCellRow = viewRowEditing;  // guardando em coordenada de VIEW
            oldCellCol = viewColEditing;
        }
    }//GEN-LAST:event_tabela_newsKeyPressed

    void event_delete() {
        int viewRow = tabela_news.getSelectedRow();
        int viewCol = tabela_news.getSelectedColumn();

        if (viewRow < 0 || viewCol < 0) {
            return;
        }

        delete_line(viewRow, viewCol);
    }

    void event_insert() {
        int viewRow = tabela_news.getSelectedRow();
        int viewCol = tabela_news.getSelectedColumn();

        if (viewRow < 0 || viewCol < 0) {
            return;
        }

        add_line(viewRow, viewCol);
    }

    private void formInternalFrameClosing(javax.swing.event.InternalFrameEvent evt) {//GEN-FIRST:event_formInternalFrameClosing
        // TODO add your handling code here:
        close_pop_up();
        if (wsClient != null) {
            try {
                wsClient.disconnectStomp();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }//GEN-LAST:event_formInternalFrameClosing

    private void formInternalFrameOpened(javax.swing.event.InternalFrameEvent evt) {//GEN-FIRST:event_formInternalFrameOpened
        // TODO add your handling code here:
        SwingUtilities.invokeLater(() -> {
            tabela_valores();
            tabela_tempo();
            att_producao();
        });

    }//GEN-LAST:event_formInternalFrameOpened

    private void tabela_newsMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_tabela_newsMouseClicked
        // TODO add your handling code here:
        if (evt.getButton() == MouseEvent.BUTTON1) {
            int viewRowEditing = tabela_news.getSelectedRow();
            int viewColEditing = tabela_news.getSelectedColumn();

            // üõë PROTE√á√ÉO: Se clicou fora (vazio), √≠ndices s√£o -1. P√°ra aqui.
            if (viewRowEditing < 0 || viewColEditing < 0) {
                return;
            }

            // üîπ AQUI ainda est√° o valor ANTIGO no model
            int modelRow = tabela_news.convertRowIndexToModel(viewRowEditing);
            int modelCol = tabela_news.convertColumnIndexToModel(viewColEditing);

            oldCellValue = tabela_news.getModel().getValueAt(modelRow, modelCol);
            oldCellRow = viewRowEditing;  // guardando em coordenada de VIEW
            oldCellCol = viewColEditing;
        }
    }//GEN-LAST:event_tabela_newsMouseClicked

    private void tabela_newsMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_tabela_newsMousePressed
        // TODO add your handling code here:
        if (evt.getButton() == MouseEvent.BUTTON1) {
            updatePopupSelecao(tabela_news);
        }
    }//GEN-LAST:event_tabela_newsMousePressed

    private void tabela_newsMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_tabela_newsMouseDragged
        // TODO add your handling code here:
        updatePopupSelecao(tabela_news);
    }//GEN-LAST:event_tabela_newsMouseDragged

    private void tabela_newsFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_tabela_newsFocusLost
        // TODO add your handling code here:
        close_pop_up();
    }//GEN-LAST:event_tabela_newsFocusLost

    private void tabela_newsComponentResized(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_tabela_newsComponentResized
        // TODO add your handling code here:
        close_pop_up();

    }//GEN-LAST:event_tabela_newsComponentResized

    void barra_titulo() {
        // Remove a barra de t√≠tulo, mas mant√©m a borda
        javax.swing.plaf.basic.BasicInternalFrameUI ui
                = (javax.swing.plaf.basic.BasicInternalFrameUI) getUI();
        ui.setNorthPane(null); // Remove a barra de t√≠tulo
        setBorder(javax.swing.BorderFactory.createEmptyBorder());
    }

    void edicao_celula() {
        // Sele√ß√£o por c√©lula
        tabela_news.setCellSelectionEnabled(true);
        tabela_news.setSurrendersFocusOnKeystroke(true);
        tabela_news.putClientProperty("JTable.autoStartsEdit", Boolean.FALSE);

        // üîÅ Listener global de in√≠cio/fim de edi√ß√£o (s√≥ precisa registrar UMA vez)
        tabela_news.addPropertyChangeListener("tableCellEditor", evt -> {
            Object newEditor = evt.getNewValue();
            if (newEditor instanceof TableCellEditor editor) {
                editor.addCellEditorListener(new javax.swing.event.CellEditorListener() {
                    @Override
                    public void editingStopped(javax.swing.event.ChangeEvent e) {
                        // edi√ß√£o confirmada (ENTER, clique fora, TAB, etc.)
                        onEditingFinished(true);
                    }

                    @Override
                    public void editingCanceled(javax.swing.event.ChangeEvent e) {
                        // edi√ß√£o cancelada (ESC)
                        onEditingFinished(false);
                    }
                });
            }
        });

        // ===== ENTER: iniciar edi√ß√£o OU finalizar edi√ß√£o =====
        InputMap im_enter = tabela_news.getInputMap(JTable.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
        ActionMap am_enter = tabela_news.getActionMap();

        im_enter.put(KeyStroke.getKeyStroke("ENTER"), "start-or-commit-edit");
        am_enter.put("start-or-commit-edit", new AbstractAction() {
            @Override
            public void actionPerformed(ActionEvent e) {

                // 1) Se J√Å est√° editando ‚Üí ENTER s√≥ faz COMMIT
                // (o unlock ser√° disparado pelo CellEditorListener.editingStopped)
                if (tabela_news.isEditing()) {
                    TableCellEditor editor = tabela_news.getCellEditor();
                    if (editor != null) {
                        editor.stopCellEditing(); // aplica no model (dispara KeyReleased)
                    }
                    return;
                }

                // 2) N√ÉO est√° editando ‚Üí tenta TRAVAR e entrar em edi√ß√£o
                int viewRow = tabela_news.getSelectedRow();
                int viewCol = tabela_news.getSelectedColumn();

                if (viewRow < 0 || viewCol < 0) {
                    return;
                }

                if (!tabela_news.isCellEditable(viewRow, viewCol)) {
                    return;
                }

                // VIEW -> MODEL
                int modelRow = tabela_news.convertRowIndexToModel(viewRow);
                int modelCol = tabela_news.convertColumnIndexToModel(viewCol);

                int sheetCol = modelCol; // ajusta se tiver coluna fake

                new Thread(() -> {
                    try {
                        System.out.printf("[ENTER] tentando lock row=%d col=%d%n", modelRow, sheetCol);
                        ApiClient.LockResult lockResult = api.tryLockCell(csv_server, modelRow, sheetCol);

                        if (!lockResult.granted) {
                            String dono = (lockResult.owner == null || lockResult.owner.isBlank())
                                    ? "outro usu√°rio"
                                    : lockResult.owner;

                            SwingUtilities.invokeLater(() -> {
                                JOptionPane.showMessageDialog(
                                        tabela_news,
                                        "Esta c√©lula est√° sendo editada por: " + dono,
                                        "C√©lula bloqueada",
                                        JOptionPane.WARNING_MESSAGE
                                );
                            });
                            return;
                        }

                        // LOCK OK ‚Üí entra em edi√ß√£o na EDT
                        SwingUtilities.invokeLater(() -> {
                            lockedRow = modelRow;
                            lockedCol = sheetCol;
                            editingViewRow = viewRow;
                            editingViewCol = viewCol;
                            editingModelRow = modelRow;
                            editingModelCol = sheetCol;

                            tabela_news.editCellAt(viewRow, viewCol);
                            Component editor = tabela_news.getEditorComponent();
                            if (editor != null) {
                                editor.requestFocusInWindow();
                            }
                            System.out.printf("[ENTER] lock OK row=%d col=%d%n", modelRow, sheetCol);
                        });

                    } catch (Exception ex) {
                        ex.printStackTrace();
                        SwingUtilities.invokeLater(() -> {
                            JOptionPane.showMessageDialog(
                                    tabela_news,
                                    "Erro ao tentar bloquear a c√©lula.\n" + ex.getMessage(),
                                    "Erro de comunica√ß√£o",
                                    JOptionPane.ERROR_MESSAGE
                            );
                        });
                    }
                }).start();
            }
        });

        // ===== ESC: cancelar edi√ß√£o (voltar valor antigo) =====
        InputMap im_esc = tabela_news.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
        ActionMap am_esc = tabela_news.getActionMap();

        im_esc.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), "cancel-edit");

        am_esc.put("cancel-edit", new AbstractAction() {
            @Override
            public void actionPerformed(ActionEvent e) {
                if (!tabela_news.isEditing()) {
                    return;
                }

                // ESC cancela a edi√ß√£o atual ‚Üí valor volta ao que era antes
                // e dispara editingCanceled ‚Üí onEditingFinished(false) ‚Üí unlock
                TableCellEditor editor = tabela_news.getCellEditor();
                if (editor != null) {
                    editor.cancelCellEditing();
                }
            }
        });
    }

    private void restaurarValorAnteriorSeMesmaCelula(int viewRow, int viewCol) {
        if (oldCellRow == viewRow && oldCellCol == viewCol && oldCellValue != null) {
            tabela_news.setValueAt(oldCellValue, viewRow, viewCol);
        }
    }

    private void onEditingFinished(boolean committed) {
        final int row;
        final int col;

        // üîí Garante que s√≥ a PRIMEIRA chamada vai executar unlock
        synchronized (this) {
            if (editingModelRow < 0 || editingModelCol < 0) {
                // J√° processamos/unlock est√° em andamento
                return;
            }

            // Captura os √≠ndices atuais
            row = editingModelRow;
            col = editingModelCol;

            // J√° limpa o estado AQUI para evitar chamadas duplicadas
            clearEditingState();
        }

        System.out.printf("[EDITOR] finished committed=%s row=%d col=%d%n",
                committed, row, col);

        // Faz o unlock em background com os √≠ndices capturados
        new Thread(() -> {
            try {
                api.unlockCell(csv_server, row, col);
                System.out.println("[EDITOR] unlock OK row=" + row + " col=" + col);
            } catch (com.app.mirrorpage.client.net.ApiClient.ApiHttpException ex) {
                String msg = ex.getMessage();
                if (msg != null
                        && msg.contains("HTTP 403")
                        && msg.contains("Not lock owner")) {
                    // J√° estava liberado / lock expirou / outra tentativa duplicada
                    System.out.println("[EDITOR] unlock 403 Not lock owner (j√° n√£o havia lock). Ignorando.");
                } else {
                    System.err.println("[EDITOR] Erro HTTP ao desbloquear c√©lula:");
                    ex.printStackTrace();
                }
            } catch (Exception ex) {
                System.err.println("[EDITOR] Erro inesperado ao desbloquear c√©lula:");
                ex.printStackTrace();
            }
        }).start();
    }

    private void clearEditingState() {
        lockedRow = -1;
        lockedCol = -1;
        editingViewRow = -1;
        editingViewCol = -1;
        editingModelRow = -1;
        editingModelCol = -1;
    }

    public void in_tMat(int line, int column, boolean save) {
        int last_line = tabela_news.getRowCount() - 2;

        if (line == -1 || line == 0 || !(column == 8 || column == 9)) {
            return;
        }

        if (line == last_line) {
            System.out.println("Alerta de vadia");
            add_line(line, column);
        }

        Object tCab = tabela_news.getValueAt(line, 8);
        Object tVt = tabela_news.getValueAt(line, 9);

        int[] cab = parseMinSec(tCab);
        int[] vt = parseMinSec(tVt);

        int totalSeg = (cab[0] * 60 + cab[1]) + (vt[0] * 60 + vt[1]);

        String tMat;
        if (totalSeg > 3599) { // maior que 59:59
            tMat = "00:00";
            Tabela.celulasComErro.add(line);
        } else {
            int min = totalSeg / 60;
            int sec = totalSeg % 60;
            tMat = String.format("%02d:%02d", min, sec);
            Tabela.celulasComErro.remove(line);
        }

        tabela_news.setValueAt(tMat, line, 10);

        if (save) {
            sync.onCellEdit(line, 10, tMat);
        }

        if (listener != null) {
            listener.tempo_producao();
            listener.att_tempo();
            listener.stts_jornal();
        }

    }

    private int[] parseMinSec(Object val) {
        if (val == null || val.toString().isEmpty()) {
            return new int[]{0, 0};
        }
        String[] parts = val.toString().trim().split(":");
        int min = parts.length > 0 ? Funcoes.parseSafe(parts[0]) : 0;
        int sec = parts.length > 1 ? Funcoes.parseSafe(parts[1]) : 0;
        return new int[]{min, sec};
    }

    void add_tempo_entrada(int modelRow, int modelCol) {
        String valor = (String) tabela_news.getValueAt(modelRow, modelCol);
        if (valor != null) {
            if (listener != null) {
                listener.inicio_jornal(valor);
                listener.att_tempo();
                listener.stts_jornal();
            }
        }

    }

    void add_tempo_encerramento(int modelRow, int modelCol) {
        String valor = (String) tabela_news.getValueAt(modelRow, modelCol);
        if (valor != null) {
            if (listener != null) {
                listener.tempo_encerramento(valor);
                listener.stts_jornal();
            }
        }
    }

    public void tempo_final(JTable table) {
        int total_lines = table.getRowCount();

        for (int c = 0; c < (total_lines - 2); c++) {
            String valor_tempo = (String) table.getValueAt(c, 13);

            String valor_tMat = (String) table.getValueAt(c, 10);
            valor_tMat = Funcoes.format_ms_to_hms(valor_tMat);

            String soma = Funcoes.soma_tempo(valor_tMat, valor_tempo);

            table.setValueAt(soma, (c + 1), 13);
        }
    }

    public void tempo_prelim_bo(JTable table) {
        int total_lines = table.getRowCount();

        for (int c = 1; c < (total_lines - 2); c++) {
            String valor_tempo = (String) table.getValueAt(c, 13);

            String valor_tMat = (String) table.getValueAt(c, 10);
            valor_tMat = Funcoes.format_ms_to_hms(valor_tMat);

            String soma = Funcoes.soma_tempo(valor_tMat, valor_tempo);
            table.setValueAt(soma, (c + 1), 13);
        }
    }

    public void tabela_valores() {
        String valor_in = (String) tabela_news.getValueAt(0, 13);

        int out = tabela_news.getRowCount() - 1;
        String valor_out = (String) tabela_news.getValueAt(out, 13);

        if (listener != null) {
            listener.inicio_jornal(valor_in);
            listener.tempo_encerramento(valor_out);
        }
    }

    public void tabela_tempo() {
        if (listener != null) {
            listener.tempo_producao();
            listener.att_tempo();
            listener.stts_jornal();
        }
    }

    void att_producao() {
        for (int row = 1; row < tabela_news.getRowCount() - 2; row++) {
            // usa a coluna 8 como base para recalcular
            in_tMat(row, 8, false);
        }
    }

    public void recalcularTodos_tMat() {
        int total = tabela_news.getRowCount();
        if (total < 3) {
            return;
        }

        int lastData = total - 2;

        for (int row = 1; row < lastData; row++) {
            in_tMat(row, 8, false);
        }
    }

    private void conectarWebSocket() {
        try {
            String wsUrl = api.getWebSocketUrl(); // ex: ws://host:8080/ws

            String topicId = csv_server
                    .replace("\\", "/")
                    .replace("/", "_");   // /BDBR/Final.csv ‚Üí _BDBR_Final.csv

            String topic = "/topic/sheet/" + topicId;

            wsClient = new SheetSocketClient(
                    new URI(wsUrl),
                    topic,
                    usuarioLogado,
                    this::onCellChangeEvent,
                    this::onRowInsertedEvent,
                    this::onRowMovedEvent,
                    this::onDeletedEvent,
                    this::onLockEvent,
                    (msg) -> {
                        Log.registrarErro_noEx("ERRO NO SHEET SOCKET CLIENTE MSG");
                    }
            );

            wsClient.connect();

        } catch (Exception e) {
            e.printStackTrace();
            System.exit(0); // Se der erro ao iniciar, mata tamb√©m
        }
    }

    private void onCellChangeEvent(CellChangeEvent evt) {

        // Campos vindos do servidor
        final String path = evt.path;
        final int modelRow = evt.row;
        final int modelCol = evt.col;
        final String value = evt.value;
        final String user = evt.user;

        // 1) Garante que √© desta planilha
        if (!csv_server.equals(path)) {
            return;
        }

        // 3) Atualizar JTable na EDT
        javax.swing.SwingUtilities.invokeLater(() -> {
            javax.swing.table.TableModel model = tabela_news.getModel();

            if (modelRow < 0 || modelRow >= model.getRowCount()) {
                System.out.printf("[WS] row fora do limite: %d (rows=%d)%n",
                        modelRow, model.getRowCount());
                return;
            }
            if (modelCol < 0 || modelCol >= model.getColumnCount()) {
                System.out.printf("[WS] col fora do limite: %d (cols=%d)%n",
                        modelCol, model.getColumnCount());
                return;
            }

            // Se tiver sorter/filtro, converter MODEL -> VIEW
            int viewRow = tabela_news.convertRowIndexToView(modelRow);
            int viewCol = tabela_news.convertColumnIndexToView(modelCol);
            int last_row = tabela_news.getRowCount() - 1; // -1 = TOTAL, -1 = index

            if (viewRow < 0 || viewCol < 0) {
                System.out.printf("[WS] viewRow/viewCol inv√°lidos: %d/%d%n", viewRow, viewCol);
                return;
            }

            System.out.printf(
                    "[WS] Aplicando mudan√ßa externa: path=%s row=%d col=%d value='%s' user=%s%n",
                    path, modelRow, modelCol, value, user
            );

            tabela_news.setValueAt(value, viewRow, viewCol);

            SwingUtilities.invokeLater(() -> {
                Tabela.ajustarLarguraColuna(tabela_news);

                if (viewCol == 8 || viewCol == 9) {
                    in_tMat(modelRow, modelCol, false);
                    return;
                }

                if (viewRow == 0 && viewCol == 13) {
                    add_tempo_entrada(viewRow, viewCol);
                    return;
                }

                if (viewRow == last_row && viewCol == 13) {
                    add_tempo_encerramento(viewRow, viewCol);
                    return;
                }
                // (Opcional) aqui d√° pra fazer highlight na c√©lula, etc.
            });

        });
    }

    private void onRowInsertedEvent(RowInsertedEvent ev) {
        if (!csv_server.equals(ev.path())) {
            return;
        }

        System.out.println("[WS] Linha inserida ap√≥s: " + ev.afterRow());

        try {
            String csv = api.loadSheet(csv_server);

            SwingUtilities.invokeLater(() -> {
                sync.aplicarCsvNoModelo(csv);
                if (oldCellRow > ev.afterRow()) {
                    oldCellRow += 1;
                }
                selecao_line(oldCellRow, oldCellCol);
                atualizarLaudaAbertaSeNecessario(ev.afterRow());
            });
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    private void onRowMovedEvent(RowMoveEvent ev) {
        // 1. Filtro de Caminho
        if (!csv_server.equals(ev.path())) {
            return;
        }

        System.out.println("[WS] Linha movida DE: " + ev.from() + " PARA: " + ev.to() + " - Quem: " + ev.user());

        try {
            String csv = api.loadSheet(csv_server);

            SwingUtilities.invokeLater(() -> {
                sync.aplicarCsvNoModelo(csv);

                if (ev.from() < ev.to()) {

                    if (oldCellRow == ev.from()) {
                        oldCellRow = ev.to();
                        return;
                    } else if (oldCellRow > ev.from() && oldCellRow <= ev.to()) {
                        oldCellRow -= 1;
                    }
                } else if (ev.from() > ev.to()) {
                    if (oldCellRow == ev.from()) {
                        oldCellRow = ev.to();
                    } else if (oldCellRow >= ev.to() && oldCellRow < ev.from()) {
                        oldCellRow += 1;
                    }
                }

                selecao_line(oldCellRow, oldCellCol);
            });
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    private void onDeletedEvent(RowDeletedEvent ev) {
        if (!csv_server.equals(ev.path())) {
            return;
        }

        System.out.println("[WS] Linha removida: " + ev.modelRow() + " Arquivo: " + ev.path() + " - Quem: " + ev.user());

        try {
            String csv = api.loadSheet(csv_server);

            SwingUtilities.invokeLater(() -> {
                sync.aplicarCsvNoModelo(csv);
                if (oldCellRow > ev.modelRow()) {
                    oldCellRow -= 1;
                }
                selecao_line(oldCellRow, oldCellCol);
            });
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    private void onLockEvent(com.app.mirrorpage.client.dto.FileLockEvent evt) {
        SwingUtilities.invokeLater(() -> {
            if (!laudaVisivel || currentLaudaPath == null || !currentLaudaPath.equals(evt.path)) {
                return;
            }
            if (usuarioLogado.equals(evt.owner)) {
                return;
            }

            // 1. SE O CONTE√öDO MUDOU, RECARREGA O TEXTO IMEDIATAMENTE
            if (evt.contentChanged) {
                System.out.println("[SYNC] Texto atualizado remotamente!");
                carregarTextoLauda(false); // false = n√£o tenta travar, s√≥ baixa
            }

            // 2. ATUALIZA O STATUS VISUAL
            if (evt.locked) {
                // Est√° bloqueado (seja novo bloqueio ou apenas um update de conte√∫do)
                laudaPanel.lblUsuario.setText("Bloqueado por: " + evt.owner);
                laudaPanel.lblUsuario.setForeground(java.awt.Color.RED);
                laudaPanel.txtTexto.setEditable(false);
                isLaudaLockedByMe = false;
            } else {
                // Foi liberado!
                laudaPanel.lblUsuario.setText("Lauda Livre");
                laudaPanel.lblUsuario.setForeground(new java.awt.Color(0, 150, 0)); // Verde
            }
        });
    }

    void add_line(int viewRow, int viewCol) {
        if (viewRow < 0) {
            return; // nada selecionado
        }

        final DefaultTableModel modelo = (DefaultTableModel) tabela_news.getModel();
        int totalRows = modelo.getRowCount();
        if (totalRows == 0) {
            return;
        }

        // √∫ltima linha de dados (pen√∫ltima da tabela: antes da TOTAL)
        int lastDataModelRow = Math.max(0, totalRows - 2);

        // VIEW -> MODEL
        int modelRow = tabela_news.convertRowIndexToModel(viewRow);
        int modelCol = tabela_news.convertRowIndexToModel(viewCol);

        // se o usu√°rio estiver embaixo da √∫ltima de dados (ex.: linha TOTAL),
        // for√ßa para usar a √∫ltima linha de dados como "afterRow"
        if (modelRow > lastDataModelRow) {
            modelRow = lastDataModelRow;
        }

        // posi√ß√£o no model onde a nova linha ser√° inserida
        int insertModelIndex = modelRow + 1;

        // ===== calcula num_pag = valor da linha anterior + 1 =====
        int numPag = 1;
        int prevRow = insertModelIndex - 1;
        if (prevRow >= 0 && prevRow < modelo.getRowCount()) {
            Object val = modelo.getValueAt(prevRow, 0);
            if (val != null) {
                try {
                    numPag = Integer.parseInt(val.toString().trim()) + 1;
                } catch (NumberFormatException e) {
                    // se n√£o for n√∫mero, mant√©m 1 (ou outro padr√£o se quiser)
                }
            }
        }

        // monta a linha vazia com seus padr√µes
        Object[] novaLinha = new Object[]{
            numPag, // primeira coluna = sequ√™ncia
            "", "", "", "", "", "", "",
            "00:00", "00:00", "00:00",
            "", "", "00:00:00", ""
        };

        // 1) insere visualmente na tabela
        modelo.insertRow(insertModelIndex, novaLinha);

        sync.onInsertRow(modelRow, modelCol);
    }

    void move_line(int viewRow, int viewCol, int rowDestView) {
        if (viewRow < 0) {
            return;
        }

        final DefaultTableModel modelo = (DefaultTableModel) tabela_news.getModel();

        // Converte para √≠ndices do modelo (dados reais)
        int modelRow = tabela_news.convertRowIndexToModel(viewRow);
        int modelCol = tabela_news.convertRowIndexToModel(viewCol);
        int rowDestModel = tabela_news.convertRowIndexToModel(rowDestView);

        // =================================================================
        // üîí BLOQUEIO DA LINHA 0 FIXA
        // =================================================================
        // Regra 1: A Linha 0 n√£o sai do lugar
        if (modelRow == 0) {
            System.out.println("Bloqueado: A linha 0 √© fixa.");
            restaurarValorAnteriorSeMesmaCelula(viewRow, viewCol); // Se tiver l√≥gica de drag visual
            return;
        }

        // Regra 2: Nenhuma linha pode ocupar o lugar da Linha 0
        if (rowDestModel == 0) {
            System.out.println("Bloqueado: N√£o pode mover para a posi√ß√£o 0.");
            restaurarValorAnteriorSeMesmaCelula(viewRow, viewCol);
            return;
        }

        // =================================================================
        // üîí BLOQUEIO DO RODAP√â
        // =================================================================
        int lastDataModelRow = modelo.getRowCount() - 2; // -1 √© Rodap√©, -2 √© √∫ltimo dado m√≥vel

        if (modelRow > lastDataModelRow || rowDestModel > lastDataModelRow) {
            restaurarValorAnteriorSeMesmaCelula(viewRow, viewCol);
            return; // Protege rodap√©
        }

        // Se passar daqui, o movimento √© V√ÅLIDO (ex: Row 1 -> Row 4)
        if (rowDestModel != modelRow) {
            modelo.moveRow(modelRow, modelRow, rowDestModel);

            // Envia para o servidor:
            // Path, from=1, to=4
            // O servidor vai calcular: realFrom=2, realTo=5 (Ok!)
            sync.onTrocarLine(modelRow, rowDestModel, modelCol, usuarioLogado);

            // Mant√©m a sele√ß√£o visual na nova posi√ß√£o
        }

        // Limpeza de vari√°veis de controle de drag
        oldCellValue = null;
        oldCellRow = -1;
        oldCellCol = -1;
    }

    void delete_line(int viewRow, int viewCol) {
        if (viewRow < 0) {
            JOptionPane.showMessageDialog(this, "Selecione uma linha para excluir.");
            return;
        }

        int modelRow = tabela_news.convertRowIndexToModel(viewRow);
        int modelCol = tabela_news.convertRowIndexToModel(viewCol);

        // Confirma√ß√£o
        int confirm = JOptionPane.showConfirmDialog(this,
                "Tem certeza que deseja excluir a linha " + (modelRow + 1) + "?",
                "Excluir", JOptionPane.YES_NO_OPTION);

        if (confirm != JOptionPane.YES_OPTION) {
            return;
        }

        sync.onDeleteLine(modelRow, modelCol);

    }

    public void selecao_line(int viewRow, int viewCol) {
        SwingUtilities.invokeLater(() -> {
            // Prote√ß√£o: se a linha/coluna n√£o existe mais, n√£o faz nada
            if (viewRow < 0 || viewRow >= tabela_news.getRowCount()) {
                return;
            }
            if (viewCol < 0 || viewCol >= tabela_news.getColumnCount()) {
                return;
            }

            tabela_news.changeSelection(viewRow, viewCol, false, false);
        });
    }

    private void enviarLinhaParaFinal() {
        // 1. Identificar a linha selecionada
        int viewRow = tabela_news.getSelectedRow();
        if (viewRow == -1) {
            JOptionPane.showMessageDialog(this, "Selecione uma linha para copiar.", "Aviso", JOptionPane.WARNING_MESSAGE);
            return;
        }

        // Converte √≠ndice visual (se tiver filtro/ordena√ß√£o) para √≠ndice real
        int modelRow = tabela_news.convertRowIndexToModel(viewRow);

        // 2. Definir Destino (Troca "Prelim" por "Final")
        // csv_server √© a vari√°vel global que guarda o caminho atual (ex: /BDBR/Prelim.csv)
        
        System.out.println("CSV: " + csv_server);
        String targetPath = csv_server.replace("Prelim", "Final");

        System.out.println("CSV: " + csv_server);
        if (targetPath.equals(csv_server)) {
            // Se o nome n√£o mudou, significa que n√£o estamos no Prelim (ou j√° estamos no Final)
            java.awt.Toolkit.getDefaultToolkit().beep(); // Barulhinho de erro
            return;
        }

        // 3. Confirma√ß√£o do Usu√°rio
        int confirm = JOptionPane.showConfirmDialog(this,
                "Deseja copiar a linha " + (modelRow + 1) + " para a planilha FINAL?",
                "Confirmar Envio (CTRL+F9)",
                JOptionPane.YES_NO_OPTION);

        if (confirm != JOptionPane.YES_OPTION) {
            return;
        }

        // 4. Execu√ß√£o em Thread (Para n√£o travar a tela enquanto espera a rede)
        new Thread(() -> {
            try {
                // Chama a API. 
                // Se der erro de Lock (409) ou Conex√£o, vai cair no CATCH.
                // Se passar direto, √© SUCESSO.
                api.copyRowToFinal(csv_server, modelRow, targetPath);

                // Feedback de Sucesso na UI
                SwingUtilities.invokeLater(() -> {
                    JOptionPane.showMessageDialog(this, "Sucesso! Linha enviada para o Final.");

                    // Opcional: Se quiser limpar a sele√ß√£o para indicar conclus√£o
                    tabela_news.clearSelection();
                });

            } catch (Exception e) {
                // Feedback de Erro na UI
                // e.getMessage() trar√° a mensagem do servidor: "Linha bloqueada. Coluna X em edi√ß√£o..."
                String msgErro = e.getMessage();

                SwingUtilities.invokeLater(() -> {
                    JOptionPane.showMessageDialog(this,
                            "N√£o foi poss√≠vel enviar:\n" + msgErro,
                            "Falha no Envio",
                            JOptionPane.ERROR_MESSAGE);
                });
            }
        }).start();
    }

    private void initLaudaSystem() {
        // 1. Inicializa o painel da lauda
        laudaPanel = new Lauda();

        laudaPanel.txtTexto.addKeyListener(new java.awt.event.KeyAdapter() {
            @Override
            public void keyPressed(java.awt.event.KeyEvent e) {
                // Verifica se apertou ALT + SETA ESQUERDA
                if (e.isAltDown() && e.getKeyCode() == java.awt.event.KeyEvent.VK_LEFT) {
                    e.consume(); // Impede que o evento digite algo ou fa√ßa outra a√ß√£o padr√£o

                    // Chama o Principal para fechar a gaveta
                    esconderLauda();

                }

                if ((e.isControlDown() || e.isMetaDown()) && e.getKeyCode() == KeyEvent.VK_S) {
                    e.consume();
                    salvarLaudaAtual(null); // null = apenas salva, n√£o faz mais nada
                }
            }
        });

        // 2. Configura o SplitPane (Divisor)
        splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
        splitPane.setResizeWeight(0.5); // 50% da tela para cada ao abrir
        splitPane.setOneTouchExpandable(true);

        // 3. Truque para capturar a tabela que j√° existe no NetBeans
        // Assumindo que voc√™ adiciona o jInternal_tabela no pn_desktop
        // Vamos limpar o pn_desktop e usar o splitPane
    }

    // Este m√©todo ser√° chamado pela Tabela quando apertar ALT+SETA
    public void alternarLauda(String tituloDaLinha) {
        if (!laudaVisivel) {
            mostrarLauda(tituloDaLinha);
        } else {
            // Se j√° estiver aberta, apenas foca no texto ou fecha? 
            // Por enquanto, vamos fechar para testar o abrir/fechar
            esconderLauda();
        }
    }

    public void mostrarLauda(String titulo) {
        int viewRow = tabela_news.getSelectedRow();
        if (viewRow == -1) {
            return;
        }

        int modelRow = tabela_news.convertRowIndexToModel(viewRow);
        this.currentLaudaRow = modelRow;
        this.currentLaudaPath = gerarPathLauda(modelRow);

        // Prepara UI (Layout)
        pn_tabela.removeAll();
        pn_tabela.setLayout(new BorderLayout());
        splitPane.setTopComponent(jScrollPane1);
        splitPane.setBottomComponent(laudaPanel);
        pn_tabela.add(splitPane, BorderLayout.CENTER);

        laudaPanel.abrirLauda(titulo, "Carregando...", usuarioLogado);
        laudaVisivel = true;

        pn_tabela.revalidate();
        pn_tabela.repaint();

        // CHAMA O NOVO M√âTODO (Com flag true para tentar lock inicial)
        carregarTextoLauda(true);

        new SwingWorker<Void, Void>() {
            String texto = "";
            boolean lockGranted = false;
            String lockOwner = "";

            @Override
            protected Void doInBackground() throws Exception {
                // 1. Busca o Texto (Ignora erro de leitura pois pode ser arquivo novo)
                try {
                    texto = api.fetchLaudaContent(currentLaudaPath);
                } catch (Exception e) {
                    texto = "";
                }

                // 2. Tenta o Lock
                // Se der erro aqui (404, 403, 500), vai lan√ßar Exception e cair no catch do done()
                ApiClient.LockResult res = api.tryLockFile(currentLaudaPath);
                lockGranted = res.granted;
                lockOwner = res.owner;

                return null;
            }

            @Override
            protected void done() {
                try {
                    // üö® O GRANDE SEGREDO: get() traz a exce√ß√£o do background para c√°
                    get();
                } catch (Exception e) {
                    e.printStackTrace(); // Mostra no console do NetBeans
                    JOptionPane.showMessageDialog(jInternal_tabela.this,
                            "ERRO T√âCNICO:\n" + e.getCause().getMessage(),
                            "Debug Lock",
                            JOptionPane.ERROR_MESSAGE);

                    // Marca como falha para cair no 'else' abaixo
                    lockGranted = false;
                }

                laudaPanel.txtTexto.setText(texto);
                laudaPanel.txtTexto.setCaretPosition(0);
                laudaPanel.txtTexto.setEnabled(true);

                isLaudaLockedByMe = lockGranted;

                if (lockGranted) {
                    // ‚úÖ Sucesso
                    laudaPanel.txtTexto.setEditable(true);
                    Log.registrarErro_noEx("MODO EDI√á√ÉO");
                    laudaPanel.lblUsuario.setText("Editando: " + usuarioLogado); // Ou "Voc√™ - Editando"
                } else if (lockOwner != null && !lockOwner.isBlank() && !lockOwner.equals("null")) {
                    // üîí Bloqueado por outro
                    laudaPanel.txtTexto.setEditable(false);
                    laudaPanel.lblUsuario.setText("Bloqueado por: " + lockOwner);
                    Log.registrarErro_noEx("Bloqueado por: " + lockOwner);
                } else {
                    // ‚ö†Ô∏è Erro T√©cnico
                    laudaPanel.txtTexto.setEditable(false);
                    laudaPanel.lblUsuario.setText("Somente Leitura");
                    Log.registrarErro_noEx("Modo Leitura (Falha ao obter Lock)");
                }

                laudaPanel.txtTexto.requestFocusInWindow();
                splitPane.setDividerLocation(0.5);
            }
        }.execute();

        // Aplica temas
        Principal root = getPrincipal();
        try {
            temaSync.aplicarTemaGeral(root, tabela_news);
        } catch (Exception e) {
            Log.registrarErro("[mostrarLauda] Aplicar Tema - ", e);
        }
    }

    public void esconderLauda() {
        // 1. Captura o estado antes de limpar
        final String pathParaLiberar = currentLaudaPath;
        final boolean euTinhaOLock = isLaudaLockedByMe;

        // 2. Destrava no Servidor (Async) - SEM SALVAR
        if (pathParaLiberar != null && euTinhaOLock) {
            new Thread(() -> {
                try {
                    api.unlockFile(pathParaLiberar);
                    System.out.println("[LAUDA] Fechado sem salvar (Unlock enviado): " + pathParaLiberar);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }).start();
        }

        // 3. Limpeza da UI (Imediata)
        pn_tabela.removeAll();
        pn_tabela.setLayout(new BorderLayout());
        pn_tabela.add(jScrollPane1, BorderLayout.CENTER);

        laudaVisivel = false;

        // Zera vari√°veis globais
        currentLaudaPath = null;
        currentLaudaRow = -1;
        isLaudaLockedByMe = false;

        pn_tabela.revalidate();
        pn_tabela.repaint();

        if (tabela_news != null) {
            tabela_news.requestFocusInWindow();
        }
    }

    private void carregarTextoLauda(boolean forcarLock) {
        if (currentLaudaPath == null) {
            return;
        }

        // Desabilita enquanto carrega para evitar edi√ß√£o durante o refresh
        laudaPanel.txtTexto.setEnabled(false);

        new SwingWorker<Void, Void>() {
            String texto = "";
            boolean lockGranted = false;
            String lockOwner = "";

            @Override
            protected Void doInBackground() throws Exception {
                // 1. Busca o conte√∫do atualizado (SYNC DE CONTE√öDO)
                try {
                    texto = api.fetchLaudaContent(currentLaudaPath);
                } catch (Exception e) {
                    texto = "";
                }

                // 2. Se pedido, tenta pegar o lock (SYNC DE BLOQUEIO)
                if (forcarLock) {
                    var res = api.tryLockFile(currentLaudaPath);
                    lockGranted = res.granted;
                    lockOwner = res.owner;
                }
                return null;
            }

            @Override
            protected void done() {
                // Atualiza o texto na tela
                laudaPanel.txtTexto.setText(texto);
                laudaPanel.txtTexto.setCaretPosition(0);
                laudaPanel.txtTexto.setEnabled(true);

                if (forcarLock) {
                    atualizarStatusLock(lockGranted, lockOwner);
                }

                // Alerta visual discreto
                System.out.println("[SYNC] Conte√∫do da lauda atualizado.");
            }
        }.execute();
    }

    // M√©todo auxiliar para atualizar as cores/texto do status
    private void atualizarStatusLock(boolean granted, String owner) {
        isLaudaLockedByMe = granted;

        if (granted) {
            laudaPanel.lblUsuario.setText("Editando: " + usuarioLogado);
            laudaPanel.lblUsuario.setForeground(new java.awt.Color(0, 150, 0)); // Verde
            laudaPanel.txtTexto.setEditable(true);
        } else if (owner != null && !owner.isBlank() && !owner.equals("null")) {
            laudaPanel.lblUsuario.setText("Bloqueado por: " + owner);
            laudaPanel.lblUsuario.setForeground(java.awt.Color.RED);
            laudaPanel.txtTexto.setEditable(false);
        } else {
            laudaPanel.lblUsuario.setText("Lauda Livre (Clique para editar)");
            laudaPanel.lblUsuario.setForeground(new java.awt.Color(0, 150, 0));

        }
    }

    private String gerarPathLauda(int modelRow) {
        String safeCsvName = csv_server
                .replace(".csv", "")
                .replaceAll("[\\\\/:*?\"<>|]", "_"); // Remove caracteres ilegais

        // Estrutura: laudas/NOME_DO_ARQUIVO/LINHA.txt
        return "laudas/" + safeCsvName + "/" + modelRow + ".txt";
    }

    private void atualizarLaudaAbertaSeNecessario(int rowAlterada) {
        // 1. Se n√£o tem lauda aberta, ou se a linha aberta n√£o √© a que mudou, ignora
        if (laudaPanel == null || !laudaPanel.isShowing() || currentLaudaRow != rowAlterada) {
            return;
        }

        // 2. Feedback visual para o usu√°rio n√£o se assustar
        laudaPanel.lblUsuario.setText("Sincronizando...");
        laudaPanel.lblUsuario.setForeground(Color.BLUE);

        new Thread(() -> {
            try {
                // 3. Calcula o caminho do arquivo .txt
                String pathTxt = calcularCaminhoLauda(csv_server, rowAlterada);

                // 4. Baixa o novo conte√∫do usando SEU m√©todo existente
                String novoConteudo = api.fetchLaudaContent(pathTxt);

                // 5. Atualiza a tela na Thread da UI
                SwingUtilities.invokeLater(() -> {
                    // Desliga listener de edi√ß√£o temporariamente se tiver
                    laudaPanel.txtTexto.setText(novoConteudo);

                    // Reseta status
                    laudaPanel.lblUsuario.setText("Atualizado externamente");
                    laudaPanel.lblUsuario.setForeground(new Color(0, 150, 0)); // Verde

                    // Move cursor para o in√≠cio
                    laudaPanel.txtTexto.setCaretPosition(0);
                });

            } catch (Exception e) {
                e.printStackTrace();
            }
        }).start();
    }

    // Converte "/BDBR/Final.csv" e linha 3 -> "laudas/_BDBR_Final/3.txt"
    private String calcularCaminhoLauda(String csvPath, int row) {
        // 1. Remove extens√£o e normaliza barras
        String nomeLimpo = csvPath.replace(".csv", "").replaceAll("[\\\\/]", "_");

        // 2. Garante que come√ßa com _
        if (!nomeLimpo.startsWith("_")) {
            nomeLimpo = "_" + nomeLimpo;
        }

        // 3. Monta o caminho relativo
        return "laudas/" + nomeLimpo + "/" + row + ".txt";
    }

    // Este m√©todo √© chamado APENAS pelo CTRL+S agora
    private void salvarLaudaAtual(Runnable acaoAposSalvar) {
        if (currentLaudaPath == null || !laudaVisivel) {
            return;
        }

        final String conteudo = laudaPanel.txtTexto.getText();
        final String path = currentLaudaPath;

        new Thread(() -> {
            try {
                // 1. Tenta pegar Lock se n√£o tiver
                if (!isLaudaLockedByMe) {
                    var res = api.tryLockFile(path);
                    if (!res.granted) {
                        SwingUtilities.invokeLater(()
                                -> JOptionPane.showMessageDialog(this, "Bloqueado por " + res.owner));
                        return;
                    }
                    isLaudaLockedByMe = true;
                }

                // 2. Salva
                api.saveLaudaContent(path, conteudo);

                // 3. Notifica atualiza√ß√£o (para os outros verem o texto novo)
                api.notifyFileUpdate(path);

                // 4. Feedback Visual
                SwingUtilities.invokeLater(() -> {
                    laudaPanel.lblUsuario.setText("Salvo!");
                    new javax.swing.Timer(1000, e -> {
                        if (isLaudaLockedByMe && laudaVisivel) {
                            laudaPanel.lblUsuario.setText("Editando: " + usuarioLogado);
                        }
                    }).start();
                });

                // Se houver callback (ex: futuro "Salvar e Sair"), executa
                if (acaoAposSalvar != null) {
                    acaoAposSalvar.run();
                }

            } catch (Exception e) {
                e.printStackTrace();
            }
        }).start();
    }

    public void updatePopupSelecao(JTable table) {
        // 1. BLINDAGEM: Se a tabela n√£o estiver vis√≠vel na tela, n√£o faz nada.
        // Isso evita o erro fatal: java.awt.IllegalComponentStateException
        if (!table.isShowing()) {
            return;
        }

        int[] rows = table.getSelectedRows();
        int[] columns = table.getSelectedColumns();

        // S√≥ mostra se tiver mais de 1 linha e pelo menos 1 coluna selecionada
        if (rows.length <= 1 || columns.length == 0) {
            close_pop_up();
            return;
        }

        String tempo = calculo_linhas_selecionadas(table);

        // 2. MELHORIA VISUAL
        JLabel label = new JLabel(tempo); // N√£o precisa de HTML se for texto simples
        label.setOpaque(true);
        label.setBackground(new Color(255, 255, 225)); // Um amarelo mais suave
        label.setFont(new Font("Segoe UI", Font.BOLD, 12));
        label.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(Color.GRAY),
                BorderFactory.createEmptyBorder(2, 5, 2, 5) // Padding: Top, Left, Bottom, Right
        ));

        try {
            // Calcula a posi√ß√£o na borda da √∫ltima c√©lula selecionada
            int ultimaLinha = rows[rows.length - 1];
            int ultimaColuna = columns[columns.length - 1];

            Rectangle cellRect = table.getCellRect(ultimaLinha, ultimaColuna, true);
            Point tablePos = table.getLocationOnScreen();

            // Posi√ß√£o: Canto inferior direito da c√©lula + um pequeno afastamento (offset)
            int x = tablePos.x + cellRect.x + cellRect.width + 5;
            int y = tablePos.y + cellRect.y + cellRect.height + 5;

            // Fecha popup anterior antes de mostrar novo
            close_pop_up();

            PopupFactory factory = PopupFactory.getSharedInstance();
            popupAtual = factory.getPopup(table, label, x, y);
            popupAtual.show();

        } catch (Exception e) {
            close_pop_up();
        }
    }

    public String calculo_linhas_selecionadas(JTable table) {
        int[] rows = table.getSelectedRows();
        if (rows.length == 0) {
            return "00:00:00";
        }
        String tempo_int = Funcoes.format_ms_to_hms((String) table.getValueAt(rows[0], 10));
        for (int i = 1; i < rows.length; i++) {
            String tempo_next = Funcoes.format_ms_to_hms((String) table.getValueAt(rows[i], 10));
            tempo_int = Funcoes.soma_tempo(tempo_int, tempo_next);
        }
        return tempo_int;
    }

    public void close_pop_up() {
        // Esconde popup anterior
        if (popupAtual != null) {
            popupAtual.hide();
            popupAtual = null;
        }
    }

    public Principal getPrincipal() {
        if (this.listener instanceof Principal) {
            return (Principal) this.listener;
        }
        return null;
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    public javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JPanel pn_tabela;
    public javax.swing.JTable tabela_news;
    // End of variables declaration//GEN-END:variables

}
